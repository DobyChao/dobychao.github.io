<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AutoBangumi Windows + Docker Desktop 部署流程</title>
    <link href="/2024/02/08/AutoBangumi-windows-docker-destop-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/02/08/AutoBangumi-windows-docker-destop-%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="autobangumi-windows-docker-部署流程"><a class="markdownIt-Anchor" href="#autobangumi-windows-docker-部署流程"></a> AutoBangumi Windows + Docker 部署流程</h1><p><strong><code>AutoBangumi</code></strong> 是基于 RSS 的全自动追番整理下载工具。只需要在 <a href="https://mikanani.me/">Mikan Project</a> 等网站上订阅番剧，就可以全自动追番。</p><p>该教程仅为个人部署 AutoBangumi 的简要记录，仅适用于个人电脑的 Windows 系统下使用 Docker Desktop 部署，不适用于服务器。</p><h2 id="安装-docker-desktop"><a class="markdownIt-Anchor" href="#安装-docker-desktop"></a> 安装 Docker Desktop</h2><p>官网下载安装，注意给C盘留一定空间。</p><p>如图，Docker Desktop 最新版本可以使用 wsl2（Windows Subsystem for Linux）为引擎，并可以集成到发行版 linux 中。</p><p><img src="image-20240209001312823.png" alt="image-20240209001312823" /></p><h2 id="部署-autobangumi"><a class="markdownIt-Anchor" href="#部署-autobangumi"></a> 部署 AutoBangumi</h2><p><code>AutoBangumi</code> 的官方文档：<a href="https://www.autobangumi.org/">https://www.autobangumi.org/</a></p><p>确保 Docker Desktop 启动后，可以选择在 Windows 环境或 wsl 环境内新建以下的文件目录：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">AutoBangumi</span>/<br>├── config/<br>└── <span class="hljs-class"><span class="hljs-keyword">data</span>/</span><br></code></pre></td></tr></table></figure><p>确保运行时目录处于 AutoBangumi 后，运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>  --name=AutoBangumi \<br>  -v $&#123;HOME&#125;/AutoBangumi/config:/app/config \<br>  -v $&#123;HOME&#125;/AutoBangumi/data:/app/data \<br>  -p 7892:7892 \<br>  -e TZ=Asia/Shanghai \<br>  -e PUID=$(id -u) \<br>  -e PGID=$(id -g) \<br>  -e UMASK=022 \<br>  --network=bridge \<br>  --dns=8.8.8.8 \<br>  --restart unless-stopped \<br>  ghcr.io/estrellaxd/auto_bangumi:latest<br></code></pre></td></tr></table></figure><p>需要注意的是，不同 shell 的续行符不同，具体可以见<a href="https://blog.csdn.net/weixin_36242811/article/details/104705395">这篇文章</a>。</p><p>部署完成后，可以在 Docker Desktop 图形化界面中见到容器已经运行：</p><p><img src="image-20240211001122881.png" alt="image-20240211001122881" /></p><p>可以通过浏览器访问映射的7892端口打开 WebUI 。</p><h2 id="配置autobangumi"><a class="markdownIt-Anchor" href="#配置autobangumi"></a> 配置AutoBangumi</h2><p>此处可以参考<a href="https://www.autobangumi.org/deploy/quick-start.html#%E9%85%8D%E7%BD%AE-autobangumi">官方文档</a>进行配置，这里主要说几个注意事项：</p><h3 id="配置下载器地址"><a class="markdownIt-Anchor" href="#配置下载器地址"></a> 配置下载器地址</h3><p>个人选择了 Windows 下安装 qBittorent，如果选择 Docker 安装则下载配置可根据官方文档设置。</p><p>这里需要先勾选 qBittorent 中的 Web 用户界面。</p><p><img src="image-20240211002442726.png" alt="image-20240211002442726" /></p><p>接下来在 Windows 下查询主机 ip 地址，可以通过 ipconfig 命令查询，一般来说是 WLAN 下的 IPv4 地址（连接 WiFi 的情况）。</p><p>将查询到的配置填入，然后最好在 qBittorrent 中将宿主机（即刚刚查询的 ip）加入身份验证白名单。</p><p><img src="image-20240211002912400.png" alt="image-20240211002912400" /></p><p>设置完成后，WebUI 右上角功能选择处启动主程序，如果操作得当（免身份验证后），可以在下载器这一栏处看到 qBittorrent 的 WebUI。</p><p>需要说明的是，主程序启动成功代表 qBittorrent 成功连接，但下载器处不一定成功显示 UI，具体可以查看这条 <a href="https://github.com/EstrellaXD/Auto_Bangumi/issues/613">Issue</a>。</p><h3 id="配置代理"><a class="markdownIt-Anchor" href="#配置代理"></a> 配置代理</h3><p>由于不可抗力，<a href="https://mikanani.me/">蜜柑计划</a>需要配置代理访问，如果是在 Windows 侧配置代理，在代理设置处需要填入宿主机的 ip，以及如果是 Clash for Windows 等代理客户端需要将 Allow LAN 选项打开（即监听局域网内的代理请求）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go学习小记</title>
    <link href="/2023/11/17/Go%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <url>/2023/11/17/Go%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Go学习小记，以一分布式KV缓存为例，学习自：<a href="https://geektutu.com/post/geecache-day1.html">https://geektutu.com/post/geecache-day1.html</a></p><p>相关代码：<a href="https://github.com/DobyChao/GoCache">https://github.com/DobyChao/GoCache</a></p><p>本文仅仅做一些Go语法或特性的记录</p><h2 id="day-1-lru"><a class="markdownIt-Anchor" href="#day-1-lru"></a> Day 1 - LRU</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_1">https://github.com/DobyChao/GoCache/tree/step_1</a></p><h3 id="定义结构体"><a class="markdownIt-Anchor" href="#定义结构体"></a> 定义结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cache is a LRU cache. It is not safe for concurrent access.</span><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>maxBytes  <span class="hljs-type">int64</span> <span class="hljs-comment">// 允许使用的最大内存，0 表示无限制</span><br>nbytes    <span class="hljs-type">int64</span> <span class="hljs-comment">// 当前已使用的内存</span><br>ll        *list.List<br>cache     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element<br>OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 某条记录被移除时的回调函数，可以为 nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>变量命名：<code>name type</code>结构，大写开头的相当于public可以被外部使用，小写相当于private只能内部使用。</li></ul><h3 id="类型断言"><a class="markdownIt-Anchor" href="#类型断言"></a> 类型断言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := x.(T)<br></code></pre></td></tr></table></figure><p>此处<code>x</code>为接口类型，如果断言成功，<code>value</code>为类型<code>T</code>。</p><h3 id="定义方法"><a class="markdownIt-Anchor" href="#定义方法"></a> 定义方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Len returns the number of cache entries</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> c.ll.Len()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="error收集"><a class="markdownIt-Anchor" href="#error收集"></a> error收集</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(params ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基本上执行一个函数或方法要按需获取<code>error</code>并处理</p><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p><a href="https://geektutu.com/post/quick-go-test.html">https://geektutu.com/post/quick-go-test.html</a></p><h2 id="day-2-单机并发缓存"><a class="markdownIt-Anchor" href="#day-2-单机并发缓存"></a> Day 2 - 单机并发缓存</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_2">https://github.com/DobyChao/GoCache/tree/step_2</a></p><h3 id="如何实现接口中的函数"><a class="markdownIt-Anchor" href="#如何实现接口中的函数"></a> 如何实现接口中的函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Getter loads data for a key.</span><br><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;<br>Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// GetterFunc implements Getter with a function.</span><br><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// Get implements Getter interface.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> f(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>Q：此处类型为<code>GetterFunc</code>的函数实现了<code>Getter</code>接口，为什么？</p><p>A：定义了<code>GetterFunc</code>的Get方法，意味着可以通过<code>func.Get(key)</code>的方式调用，符合接口要求。</p><h3 id="锁的使用"><a class="markdownIt-Anchor" href="#锁的使用"></a> 锁的使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br>mu         sync.Mutex <span class="hljs-comment">// 互斥锁</span><br>muRW       sync.RWMutex <span class="hljs-comment">// 读写锁</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">A</span><span class="hljs-params">()</span></span> &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    DoSomething()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>defer</code>保证了函数<code>A</code>结束其调用栈后（包括异常）一定会执行解锁。</p><h2 id="day-3-http-服务端"><a class="markdownIt-Anchor" href="#day-3-http-服务端"></a> Day 3 - HTTP 服务端</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_3">https://github.com/DobyChao/GoCache/tree/step_3</a></p><h3 id="使用-gin-框架快速创建一个服务端"><a class="markdownIt-Anchor" href="#使用-gin-框架快速创建一个服务端"></a> 使用 Gin 框架快速创建一个服务端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HTTPPool)</span></span> LoadRouters(router *gin.Engine) &#123;<br>router.GET(p.basePath+<span class="hljs-string">&quot;/:groupname/:key&quot;</span>, p.getCache)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HTTPPool)</span></span> getCache(c *gin.Context) &#123;<br>groupname := c.Param(<span class="hljs-string">&quot;groupname&quot;</span>)<br>key := c.Param(<span class="hljs-string">&quot;key&quot;</span>)<br><br>group := GetGroup(groupname)<br><span class="hljs-keyword">if</span> group == <span class="hljs-literal">nil</span> &#123;<br>c.String(http.StatusBadRequest, <span class="hljs-string">&quot;no such group&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>view, err := group.Get(key)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.String(http.StatusInternalServerError, err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c.Data(http.StatusOK, <span class="hljs-string">&quot;application/octet-stream&quot;</span>, view.ByteSlice())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    r := gin.Default()<br>peers := gocache.NewHTTPPool(<span class="hljs-string">&quot;localhost:9999&quot;</span>)<br>peers.LoadRouters(r)<br>r.Run(<span class="hljs-string">&quot;:9999&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="day-4-一致性哈希"><a class="markdownIt-Anchor" href="#day-4-一致性哈希"></a> Day 4 - 一致性哈希</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_4">https://github.com/DobyChao/GoCache/tree/step_4</a></p><h3 id="sort-的用法"><a class="markdownIt-Anchor" href="#sort-的用法"></a> sort 的用法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><br><br><span class="hljs-comment">// 整型排序</span><br>sort.Ints(m.keys)<br><br><span class="hljs-comment">// 对有序切片二分查找</span><br>idx := sort.Search(<span class="hljs-built_in">len</span>(m.keys), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> m.keys[i] &gt;= hash<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="day-5-分布式缓存"><a class="markdownIt-Anchor" href="#day-5-分布式缓存"></a> Day 5 - 分布式缓存</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_5">https://github.com/DobyChao/GoCache/tree/step_5</a></p><h3 id="确认接口是否被实现"><a class="markdownIt-Anchor" href="#确认接口是否被实现"></a> 确认接口是否被实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PeerPicker is the interface that must be implemented to locate</span><br><span class="hljs-comment">// the peer that owns a specific key.</span><br><span class="hljs-keyword">type</span> PeerPicker <span class="hljs-keyword">interface</span> &#123;<br>PickPeer(key <span class="hljs-type">string</span>) (peer PeerGetter, ok <span class="hljs-type">bool</span>)<br>&#125;<br><br><span class="hljs-comment">// PeerGetter is the interface that must be implemented by a peer.</span><br><span class="hljs-keyword">type</span> PeerGetter <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Get returns the value form the group.</span><br>Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// check that HTTPPool implements PeerPicker</span><br><span class="hljs-keyword">var</span> _ PeerPicker = (*HTTPPool)(<span class="hljs-literal">nil</span>)<br><br><br><span class="hljs-comment">// check that httpGetter implements PeerGetter</span><br><span class="hljs-keyword">var</span> _ PeerGetter = (*httpGetter)(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><p>很妙吧，我也觉得妙</p><h3 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;flag&quot;</span><br><br><span class="hljs-comment">// 因式分解写法</span><br><span class="hljs-keyword">var</span> (<br>    port <span class="hljs-type">int</span><br>    api  <span class="hljs-type">bool</span><br>)<br><span class="hljs-comment">// cli arguments</span><br>flag.IntVar(&amp;port, <span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-number">8001</span>, <span class="hljs-string">&quot;gocache server port&quot;</span>) <span class="hljs-comment">// which port to listen</span><br>flag.BoolVar(&amp;api, <span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;start a api server?&quot;</span>)<br>flag.Parse()<br></code></pre></td></tr></table></figure><p>有点像 python 中的 <code>argparse</code></p><h2 id="day-6-防止缓存击穿"><a class="markdownIt-Anchor" href="#day-6-防止缓存击穿"></a> Day 6 - 防止缓存击穿</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_6">https://github.com/DobyChao/GoCache/tree/step_6</a></p><h2 id="day-7-使用-protobuf-通信"><a class="markdownIt-Anchor" href="#day-7-使用-protobuf-通信"></a> Day 7 - 使用 Protobuf 通信</h2><p><a href="https://github.com/DobyChao/GoCache/tree/step_7">https://github.com/DobyChao/GoCache/tree/step_7</a></p><h3 id="protobuf使用教程"><a class="markdownIt-Anchor" href="#protobuf使用教程"></a> Protobuf使用教程</h3><p><a href="https://geektutu.com/post/quick-go-protobuf.html">https://geektutu.com/post/quick-go-protobuf.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-comment">// &quot;github.com/golang/protobuf/proto&quot; // 这个已不再维护</span><br>    <span class="hljs-string">&quot;google.golang.org/protobuf/proto&quot;</span> <span class="hljs-comment">// 使用这个</span><br>)<br></code></pre></td></tr></table></figure><h2 id="感想"><a class="markdownIt-Anchor" href="#感想"></a> 感想</h2><ul><li>Go 写起来感觉和 python 差不多，但包管理的确不太好用</li><li>Go 是一个没有类概念的面向对象语言，通过结构体、方法、接口来实现面向对象的特性</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/06/hello-world/"/>
    <url>/2023/11/06/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
